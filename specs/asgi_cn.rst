<div><br class="Apple-interchange-newline">==========================================================
ASGI (异步服务器网关接口) 规范
==========================================================

**版本**: 3.0 (2019-03-20)

摘要
========

本文档提出了一种网络协议服务器（特别是 Web 服务器）和 Python 应用程序之间的标准接口，旨在允许处理多种常见协议样式（包括 HTTP、HTTP/2 和 WebSocket）。

本基本规范旨在确定这些服务器交互和运行应用程序代码的 API 集；
每个支持的协议（例如 HTTP）都有一个子规范，概述如何将该协议编码和解码为消息。


基本原理
=========

WSGI 规范自推出以来运行良好，
并且允许 Python 框架和 Web 服务器选择有很大的灵活性。
然而，它的设计与 HTTP 样式的
请求/响应周期不可分割，越来越多不遵循这种
模式的协议正在成为 Web 编程的标准部分（最值得注意的是
WebSocket）。

ASGI 试图保留简单的应用程序接口，同时提供一个
抽象，允许在任何时间以及从不同的应用程序线程或进程发送和接收数据。

它还将将协议转换为与 Python 兼容的原则，
异步友好的消息集，并将其概括为两个部分；
围绕其构建服务器的标准化通信接口（本文档）和每种协议的一组标准消息格式。

它的主要目标是提供一种编写 HTTP/2 和 WebSocket 代码的方法
与正常的 HTTP 处理代码一起，但是；这种设计的一部分意味着
确保存在一个容易使用现有 WSGI 服务器和
应用程序的路径，因为绝大多数 Python Web 使用依赖于 WSGI，并且
提供一条前进的轻松路径对于采用至关重要。关于此的详细信息
互操作性在 ASGI-HTTP 规范中有所介绍。


概述
========

ASGI 由两个不同的部分组成：

- 一个 *协议服务器*，它终止套接字并将它们转换为
连接和每个连接的事件消息。

- 一个 *应用程序*，它存在于 *协议服务器* 内，在每次调用
连接时，并根据发生的事情处理事件消息，并在必要时发出自己的
事件消息。

与 WSGI 类似，服务器在其内部托管应用程序，并将传入
请求以标准化格式分派给它。然而，与 WSGI 不同，应用程序
是异步可调用而不是简单的可调用，并且它们通过接收和发送异步事件消息与
服务器进行通信，而不是接收
单个输入流并返回单个可迭代对象。ASGI 应用程序必须运行为
``async`` / ``await`` 兼容协程（即 ``asyncio`` 兼容）（在主线程上；
如果它们需要同步
代码，则可以自由使用线程或其他进程）。

与 WSGI 不同，ASGI 连接有两个独立的部分：

- 一个 *连接范围*，它代表与用户的协议连接，并且
在连接关闭之前一直存在。

- *事件*，即在连接上发生事情时发送到应用程序的消息，以及由应用程序发送以供服务器接收的消息，
包括要传输到客户端的数据。

应用程序使用连接 ``范围`` 和两个可等待
可调用对象来调用并等待 ``接收`` 事件消息和 ``发送`` 事件消息。所有这些
都在异步事件循环中发生。

应用程序可调用对象的每次调用都映射到一个传入的“套接字”或
连接，并且预期该连接将持续连接的整个生命周期以及一小段时间
更长时间，如果有清理工作要做。某些协议可能不使用传统的套接字；ASGI
针对这些协议的规范预计将定义范围生命周期是什么
以及它何时关闭。


规范详细信息
=====================

连接范围
----------------

用户与 ASGI 应用程序的每个连接都会导致对该应用程序的调用
应用程序可调用对象来完全处理该连接。它的生命周期有多长，
以及描述每个特定连接的信息，称为
*连接范围*。

密切相关，传递给应用程序可调用对象的第一个参数是
一个 ``范围`` 字典，其中包含描述该特定连接的所有信息。

例如，在 HTTP 下，连接范围只持续一个请求，但 ``范围``
传递的包含大多数请求数据（除了 HTTP 请求体之外，因为这是
通过事件流式传输）。

然而，在 WebSocket 下，连接范围持续时间与套接字相同
已连接。传递的 ``范围`` 包含有关 WebSocket 的信息，如路径，但
像传入消息之类的详细信息是作为事件而不是作为事件传入的。

某些协议可能会为您提供一个 ``范围``，其中包含非常有限的信息
提前，因为它们封装了类似于握手的东西。每个协议
定义必须包含有关其连接范围持续时间的信息，
以及您将在 ``范围`` 参数中获得哪些信息。

根据协议规范，应用程序可能需要等待一个初始的
打开消息才能与客户端通信。


事件
------

ASGI 将协议分解为一系列 *事件*，应用程序必须
*接收* 并做出反应，以及应用程序可能 *发送* 的 *事件* 作为响应。
对于 HTTP，这就像按顺序 *接收* 两个事件一样简单 - ``http.request``
和 ``http.disconnect``，以及 *发送* 对应的事件消息返回。为了
像 WebSocket 这样的东西，它可能更像是 *接收* ``websocket.connect``，
*发送* ``websocket.send``，*接收* ``websocket.receive``，最后
*接收* ``websocket.disconnect``。

每个事件都是一个 ``dict``，具有顶级的 ``type`` 键，其中包含一个
事件类型类型的 Unicode 字符串。用户可以自由地发明自己的消息
类型并在应用程序实例之间发送它们以进行高级事件 - 例如，一个聊天
应用程序可能会发送带有用户类型的聊天消息
``mychat.message``。预计应用程序应该能够处理
混合事件集，有些来自传入的客户端连接，有些来自
应用程序的其他部分。

由于这些消息可能通过网络发送，因此它们需要是
可序列化的，因此它们只允许包含以下类型：

* 字节串
* Unicode 字符串
* 整数（在有符号 64 位范围内）
* 浮点数（在 IEEE 754 双精度范围内；没有
``Nan`` 或无穷大）
* 列表（元组应编码为列表）
* 字典（键必须是 Unicode 字符串）
* 布尔值
* ``None``


应用程序
------------

.. 注意::

应用程序格式在 3.0 中更改为使用单个可调用对象，而不是
先前的双可调用格式。双可调用对象在下面“遗留应用程序”中进行了解释；服务器可以轻松实现对它的支持
使用 ``asgiref.compatibility`` 库，并应尝试支持它。

ASGI 应用程序应为单个异步可调用对象::

协程 application(scope, receive, send)

* ``scope``：连接范围信息，一个字典，至少包含一个
``type`` 键指定传入的协议
* ``receive``：一个可等待的可调用对象，将在
新的事件字典可用时
* ``send``：一个可等待的可调用对象，它接受一个事件字典作为
位置参数，它将在发送完成后返回
已完成或连接已关闭

应用程序为每个“连接”调用一次。连接的定义
以及它的寿命由所讨论的协议规范决定。为了
例如，对于 HTTP，它是一个请求，而对于 WebSocket，它是一个
WebSocket 连接。

``范围`` 和您发送和接收的事件消息的格式
由应用程序协议之一定义。``scope`` 必须是
``dict``。 键 ``scope["type"]`` 将始终存在，并且可以
用于找出传入的协议。 键
``scope["asgi"]`` 也将存在，作为一个包含
``scope["asgi"]["version"]`` 键，对应于 ASGI 版本
服务器实现。如果丢失，则版本应默认为 ``"2.0"``.

还可能存在特定于规范的版本作为
``scope["asgi"]["spec_version"]``. 这允许各个协议
规范在不更改总体 ASGI 版本的情况下进行增强。

特定于协议的子规范涵盖了这些范围和事件消息格式。
它们等效于 ``environ`` 中键的规范字典用于
WSGI。


遗留应用程序
-------------------

遗留（v2.0）ASGI 应用程序定义为可调用对象::

application(scope)

它返回另一个可等待的可调用对象::

协程 application_instance(receive, send)

``范围``、``接收`` 和 ``发送`` 的含义与
较新的单个可调用应用程序相同，但请注意，第一个可调用对象是
*同步的*。

第一个可调用对象在连接启动时被调用，然后
第二个可调用对象立即被调用并等待。

这种风格在版本 3.0 中被弃用，因为双可调用布局被认为是
不必要。现在它已经过时了，但是那里存在使用
这种风格编写的应用程序，因此支持它们很重要。

在 ``asgiref.compatibility`` 中有一个兼容性套件
模块，它允许您同时检测遗留应用程序和将它们转换为
新的单协议风格无缝衔接。从 ASGI 3.0 开始，鼓励服务器支持
两种类型，并逐渐默认删除对它们的默认支持。


协议规范
-----------------------

这些描述了各种
协议的标准化范围和消息格式。

所有范围和消息中共同的键是 ``type``，这是一种方式
指示接收到的范围或事件消息的类型。

在范围内，``type`` 键必须是一个 Unicode 字符串，如 ``"http"`` 或
``"websocket"``，如相关协议规范中定义的那样。

在消息中，``type`` 应命名空间为 ``protocol.message_type``，
其中 ``protocol`` 与范围类型匹配，并且 ``message_type`` 是
由协议规范定义的。消息 ``type`` 值的示例包括
``http.request`` 和 ``websocket.send``。

.. 注意::

应用程序应积极拒绝任何它们不理解的协议
带有 `Exception`（任何类型）。未能做到这一点可能会导致
服务器认为您支持您不支持的协议，这会导致混乱
在使用 Lifespan 协议时，因为服务器将在您
告诉它。


当前的协议规范：

* :doc:`HTTP 和 WebSocket <www>`
* :doc:`Lifespan <lifespan>`


中间件
----------

可以有 ASGI“中间件”——代码既充当
服务器又充当应用程序，接收 ``范围`` 以及 ``send``/``receive`` 可等待的可调用对象，
可能会修改它们，然后调用内部应用程序。

当中间件修改 ``范围`` 时，它应该复制 ``范围``
对象在进行修改和将其传递到内部应用程序之前，因为更改
否则可能会泄漏到上游。特别地，您不应假设该副本
您传递给应用程序的范围是它最终使用的范围，
因为可能还有其他中间件在其中；因此，不要保留对它的引用，并且不要试图在 ASGI 应用程序调用之外进行修改。您修改它的唯一机会是在
您将控制权交给子应用程序之前。


错误处理
--------------

如果服务器接收到无效的事件字典 - 例如，具有
未知的 ``type``、缺少事件类型应该具有的键，或使用错误的 Python
对象类型（例如，HTTP 头的 Unicode 字符串） - 它应该抛出一个
异常来自 ``send`` 可等待的对象返回到应用程序。

如果应用程序从 ``receive`` 接收到无效的事件字典，它
应该抛出异常。

在这两种情况下，事件字典中存在附加键不应
抛出异常。这允许协议进行非中断升级
随着时间的推移进行规范。

服务器可以自由地将从其运行的应用程序实例中冒泡的错误表面化
他们希望的任何方式 - 记录到控制台，发送到系统日志，或其他
选项 - 但如果发生这种情况，他们必须终止应用程序实例及其关联的
连接。

请注意，在连接关闭后由服务器接收的消息通常不被视为错误，除非
由协议指定。
如果没有指定错误条件，则 ``send`` 可等待的可调用对象应该充当
无操作。

即使在 ``send()`` 上抛出错误，它也应该是
一个错误类，如果它是在应用程序之外抛出的，服务器会捕获并忽略该类，
确保服务器本身在过程中不会出错。


扩展
----------

在某些情况下，协议服务器可能希望提供特定于服务器的
扩展，超出了核心 ASGI 协议规范，或者当更改
到规范正在试用中，然后才会推出。

对于这种情况，我们定义了 ``extensions`` 的通用模式 - 命名
对协议规范的添加，这些添加是可选的，但如果
由服务器提供并且应用程序理解，可以用来获取更多
功能。

这是通过 ``范围`` 字典中的 ``extensions`` 条目实现的，它
本身是一个 ``dict``。扩展有一个 Unicode 字符串名称，该名称
是服务器和应用程序之间商定的。

如果服务器支持扩展，它应该将一个条目放置到
``extensions`` 字典，在扩展的名称下，该条目的值应该本身是一个
``dict``。服务器可以在此值内部提供任何额外的范围信息，或者
扩展仅仅是为了指示服务器通过
``send`` 可调用对象，它可能只是一个空的 ``dict``。

例如，想象一下 HTTP 协议服务器希望提供一个扩展
它允许发送一个新的事件回到服务器，该事件试图刷新
通过 OS 级别网络发送缓冲区。它提供一个空的条目
在 ``extensions`` 字典中表示它可以处理该事件::

scope = {
"type": "http",
"method": "GET",
...
"extensions": {
"fullflush": {},
},
}

如果应用程序看到了这一点，那么它就知道它可以通过
``send`` 可调用对象。


字符串和 Unicode
-------------------

在本文档中，以及所有子规范中，*字节串* 指的是
Python 3 中的 ``bytes`` 类型。*Unicode 字符串* 指的是 ``str`` 类型
在 Python 3 中。

本文档永远不会只指定 *字符串* - 所有字符串都是两者之一
精确的类型。

提到的所有 ``dict`` 键（包括 *范围* 和 *事件* 的键）都是
Unicode 字符串。


版本历史
===============

* 3.0 (2019-03-04): 更改为单个可调用应用程序样式
* 2.0 (2017-11-28): 初始非通道层 ASGI 规范


版权
=========

本文件已进入公有领域。</div>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
