## HTTP 和 WebSocket ASGI 消息格式

====================================
HTTP & WebSocket ASGI 消息格式
====================================

**版本**: 2.5 (2024-06-05)

HTTP+WebSocket ASGI 子规范概述了如何在 ASGI 中传输 HTTP/1.1、HTTP/2 和 WebSocket 连接。

该规范的目的是作为 WSGI 格式的超集，并指定如何针对 WSGI 可处理的请求集在两种格式之间进行转换。


规范版本
-------------

该规范有以下版本：

* ``2.0``: 该规范的第一个版本，随 ASGI 2.0 发布。
* ``2.1``: 向 WebSocket 接受响应添加了 ``headers`` 键。
* ``2.2``: 允许在 ``server`` 范围值的第二个项目中使用 ``None``。
* ``2.3``: 向 WebSocket 关闭事件添加了 ``reason`` 键。
* ``2.4``: 在已关闭的连接上调用 ``send()`` 应该会引发错误。
* ``2.5``: 向 WebSocket 断开连接事件添加了 ``reason`` 键。

规范版本可以帮助你了解正在使用的服务器所支持的规范版本。例如，如果服务器表示只支持该规范的 ``2.0`` 版本，则向 WebSocket 接受消息发送 ``headers`` 将会导致错误。

规范版本与 HTTP 版本或 ASGI 版本是分开的。


HTTP
----

HTTP 格式涵盖 HTTP/1.0、HTTP/1.1 和 HTTP/2，因为 HTTP/2 中的变化主要是在传输级别。协议服务器应该对同一个 HTTP/2 连接上的不同请求给出不同的范围，并正确地将响应多路复用到它们所在的相同流中。HTTP 版本以字符串形式在范围内提供。

具有相同名称的多个标头字段在 HTTP 中很复杂。RFC 7230 规定，对于任何可以重复出现的标头字段，等效于仅发送一次该标头字段，并将所有值用逗号连接起来。

然而，对于 HTTP cookie (``Cookie`` 和 ``Set-Cookie``)，允许的行为不符合上述规则，并且根据 HTTP 协议版本略有不同：

* 对于 HTTP/1.0、HTTP/1.1 和 HTTP2.0 中的 ``Set-Cookie`` 标头，它可以重复出现，但不能用逗号 (或其他任何符号) 连接到单个标头字段中。

* 对于 ``Cookie`` 标头，在 HTTP/1.0 和 HTTP/1.1 中，RFC 7230 和 RFC 6265 明确规定 ``Cookie`` 标头只能由用户代理发送一次，并且必须使用 0x3b、0x20 (ASCII 字符串 "; ") 的两个字节分隔符连接到一个字节串中。然而，在 HTTP/2 中，RFC 9113 规定 ``Cookie`` 标头可以重复出现，或者可以使用 0x3b、0x20 (ASCII 字符串 "; ") 的两个字节分隔符连接起来。

ASGI 的设计决策是将请求和响应标头都传输为 2 元素的 ``[name, value]`` 列表，并保留与提供的标头完全相同的内容。

对于支持 HTTP/2 的 ASGI 应用程序，应注意处理上面提到的 ``Cookie`` 的特殊情况。

HTTP 协议应该用 ``type`` 值为 ``http`` 来标识给 ASGI 应用程序。


HTTP 连接范围
'''''''''''''''''''''

HTTP 连接具有单一请求的 *连接范围* - 也就是说，你的应用程序将在请求开始时被调用，并将持续到该特定请求结束，即使底层套接字仍然处于打开状态并正在为多个请求提供服务。

如果你为长时间轮询或类似操作保持响应打开，*连接范围* 将一直持续到来自客户端或服务器端响应关闭。

传递到 ``scope`` 中的 *连接范围* 信息包含：

* ``type`` (*Unicode 字符串*) -- ``"http"``。

* ``asgi["version"]`` (*Unicode 字符串*) -- ASGI 规范的版本。

* ``asgi["spec_version"]`` (*Unicode 字符串*) -- 此服务器理解的 ASGI HTTP 规范的版本；可以是 ``"2.0"``、``"2.1"``、``"2.2"`` 或 ``"2.3"`` 之一。可选；如果缺失，则假设为 ``2.0``。

* ``http_version`` (*Unicode 字符串*) -- 可以是 ``"1.0"``、``"1.1"`` 或 ``"2"`` 之一。

* ``method`` (*Unicode 字符串*) -- HTTP 方法名称，全部大写。

* ``scheme`` (*Unicode 字符串*) -- URL 方案部分 (可能是 ``"http"`` 或 ``"https"``)。可选 (但不能为空)；默认值为 ``"http"``。

* ``path`` (*Unicode 字符串*) -- HTTP 请求目标，不包括任何查询字符串，其中百分号编码的序列和 UTF-8 字节序列已解码为字符。

* ``raw_path`` (*字节字符串*) -- 原始 HTTP 路径组件，不包括任何查询字符串，与 Web 服务器接收到的字节相同。某些 Web 服务器实现可能无法提供此项。可选；如果缺失，则默认为 ``None``。

* ``query_string`` (*字节字符串*) -- ``?`` 后的 URL 部分，百分号编码。

* ``root_path`` (*Unicode 字符串*) -- 此应用程序挂载到的根路径；与 WSGI 中的 ``SCRIPT_NAME`` 相同。可选；如果缺失，则默认为 ``""``。

* ``headers`` (*Iterable[[字节字符串, 字节字符串]]*) -- 一个包含 ``[name, value]`` 两个元素可迭代对象的列表，其中 ``name`` 是标头名称，``value`` 是标头值。标头值的顺序必须保留来自原始 HTTP 请求的顺序；标头名称的顺序不重要。重复项是可能的，并且必须在接收到的消息中保留。标头名称应该小写，但这不是必需的；服务器应该尽最大努力保留标头大小写。伪标头 (存在于 HTTP/2 和 HTTP/3 中) 必须删除；如果存在 ``:authority``，则其值必须使用 ``host`` 作为标头名称添加到可迭代对象的开头，或替换任何现有的 host 标头。

* ``client`` (*Iterable[Unicode 字符串, 整数]*) -- 一个包含 ``[host, port]`` 两个元素可迭代对象的列表，其中 ``host`` 是远程主机的 IPv4 或 IPv6 地址，``port`` 是远程端口，表示为整数。可选；如果缺失，则默认为 ``None``。

* ``server`` (*Iterable[Unicode 字符串, Optional[整数]]*) -- 一个包含 ``[host, port]`` 两个元素可迭代对象的列表，其中 ``host`` 是此服务器的监听地址，``port`` 是监听端口的整数，或 ``[path, None]``，其中 ``path`` 是 Unix 套接字的路径。可选；如果缺失，则默认为 ``None``。

* ``state`` 可选(*dict[Unicode 字符串, Any]*) -- 传递到与该请求相对应的生命周期的命名空间的副本。（参见 :doc:`lifespan`)。可选；如果缺失，则表示服务器不支持此功能。

服务器负责处理入站和出站分块传输编码。具有 ``chunked`` 编码主体 (body) 的请求应该由服务器自动去分块，并以纯文本主体字节形式提供给应用程序；如果服务器为没有设置 ``Content-Length`` 的响应提供了响应，则可能会根据服务器的判断进行分块。


请求 - ``receive`` 事件
'''''''''''''''''''''''''''

发送给应用程序以指示传入的请求。大多数请求信息都包含在连接 ``scope`` 中；主体消息是用于以块的形式流式传输大型传入 HTTP 主体的工具，也是实际运行请求代码的触发器 (因为你不应该在连接打开时就触发)。

请注意，如果使用 ``Transfer-Encoding: chunked`` 发送请求，服务器将负责处理这种编码。``http.request`` 消息应该只包含每个块的解码内容。

键：

* ``type`` (*Unicode 字符串*) -- ``"http.request"``。

* ``body`` (*字节字符串*) -- 请求主体。可选；如果缺失，则默认为 ``b""``。如果设置了 ``more_body``，则将其视为主体的开始并将其附加在后续块上。

* ``more_body`` (*布尔值*) -- 指示是否有更多内容即将到来 (作为请求消息的一部分)。如果为 ``True``，则使用该内容的应用程序应该等待，直到它获得一个将此设置为此值为 ``False`` 的块。如果为 ``False``，则请求已完成，应进行处理。可选；如果缺失，则默认为 ``False``。


响应开始 - ``send`` 事件
'''''''''''''''''''''''''''''''

应用程序发送此事件以开始向客户端发送响应。至少需要紧随一个响应内容消息。

协议服务器 *不需要* 将此事件生成的数据冲刷到发送缓冲区，直到第一个 *响应主体* 事件被处理。这可能会使他们有更多空间，以便在处理请求时发生内部错误的情况下，用错误响应替换响应。

你可以在此消息中发送 ``Transfer-Encoding`` 标头，但服务器必须忽略它。服务器本身会处理 ``Transfer-Encoding``，并且可以选择使用 ``Transfer-Encoding: chunked``，如果应用程序提供的响应没有设置 ``Content-Length``。

请注意，这与 ``Content-Encoding`` 不同，``Content-Encoding`` 仍然由应用程序控制，是设置 ``gzip`` 或其他压缩标志的合适位置。

键：

* ``type`` (*Unicode 字符串*) -- ``"http.response.start"``。

* ``status`` (*整数*) -- HTTP 状态代码。

* ``headers`` (*Iterable[[字节字符串, 字节字符串]]*) -- 一个包含 ``[name, value]`` 两个元素可迭代对象的列表，其中 ``name`` 是标头名称，``value`` 是标头值。顺序必须保留在 HTTP 响应中。标头名称必须小写。可选；如果缺失，则默认为一个空列表。伪标头 (存在于 HTTP/2 和 HTTP/3 中) 不得出现。

* ``trailers`` (*布尔值*) -- 指示应用程序是否会发送尾部标头。如果为 ``True``，则服务器必须在 *响应主体* 事件后等待接收一个 ``"http.response.trailers"`` 消息。可选；如果缺失，则默认为 ``False``。


响应主体 - ``send`` 事件
''''''''''''''''''''''''''''''

继续向客户端发送响应。协议服务器必须在从发送调用返回之前，将传递给它们的所有数据冲刷到发送缓冲区。如果 ``more_body`` 被设置为 ``False``，并且服务器不希望 *响应尾部标头*，这将完成响应。

键：

* ``type`` (*Unicode 字符串*) -- ``"http.response.body"``。

* ``body`` (*字节字符串*) -- HTTP 主体内容。与在此连接范围内发送的任何先前的 ``body`` 值连接在一起。可选；如果缺失，则默认为 ``b""``。

* ``more_body`` (*布尔值*) -- 指示是否有更多内容即将到来 (作为 *响应主体* 消息的一部分)。如果为 ``False``，并且服务器不希望 *响应尾部标头*，则响应将被视为已完成并关闭，并且该通道上的任何进一步消息都将被忽略。可选；如果缺失，则默认为 ``False``。


断开的客户端 - ``send`` 异常
''''''''''''''''''''''''''''''''''''''''

如果在已关闭的连接上调用 ``send()``，则服务器应该引发一个服务器特定的 ``IOError`` 子类。但这并非一定保证，尤其是在较旧的 ASGI 服务器实现中 (它是在规范版本 2.4 中引入的)。

应用程序可以捕获此异常，并在重新抛出或无异常返回之前执行清理工作。

服务器必须准备好捕获此异常（如果它们引发了此异常），并且不应该将其记录为其服务器日志中的错误。


断开连接 - ``receive`` 事件
''''''''''''''''''''''''''''''

如果在发送响应或 HTTP 连接关闭后调用接收时，发送到应用程序。这主要用于长时间轮询，如果连接过早关闭，你可能需要触发清理代码。

在你收到此事件后，你应该预计未来对 ``send()`` 的调用会引发异常，如上所述。但是，如果你的代码具有高度并发性，你可能会发现对 ``send()`` 的调用在收到此事件之前就稍微错误。

键：

* ``type`` (*Unicode 字符串*) -- ``"http.disconnect"``。


WebSocket
---------

WebSocket 共享一些 HTTP 详细信息 (它们具有路径和标头)，但也具有更多状态。同样，大多数状态都包含在 ``scope`` 中，并且该范围的寿命与套接字的寿命相同。

WebSocket 协议服务器应该自行处理 PING/PONG 消息，并根据需要发送 PING 消息以确保连接处于活动状态。

WebSocket 协议服务器应该自行处理消息碎片，并将完整的消息传递给应用程序。

WebSocket 协议应该用 ``type`` 值为 ``websocket`` 来标识给 ASGI 应用程序。


Websocket 连接范围
''''''''''''''''''''''''''

WebSocket 连接的范围与套接字本身的寿命相同 - 如果应用程序关闭，则套接字应该关闭，反之亦然。

传递到 ``scope`` 中的 *连接范围* 信息包含初始连接元数据 (主要是来自 HTTP 请求行和标头的元数据)：

* ``type`` (*Unicode 字符串*) -- ``"websocket"``。

* ``asgi["version"]`` (*Unicode 字符串*) -- ASGI 规范的版本。

* ``asgi["spec_version"]`` (*Unicode 字符串*) -- 此服务器理解的 ASGI HTTP 规范的版本；可以是 ``"2.0"``、``"2.1"``、``"2.2"`` 或 ``"2.3"`` 之一。可选；如果缺失，则假设为 ``"2.0"``。

* ``http_version`` (*Unicode 字符串*) -- 可以是 ``"1.1"`` 或 ``"2"`` 之一。可选；如果缺失，则默认为 ``"1.1"``。

* ``scheme`` (*Unicode 字符串*) -- URL 方案部分 (可能是 ``"ws"`` 或 ``"wss"``)。可选 (但不能为空)；默认值为 ``"ws"``。

* ``path`` (*Unicode 字符串*) -- HTTP 请求目标，不包括任何查询字符串，其中百分号编码的序列和 UTF-8 字节序列已解码为字符。

* ``raw_path`` (*字节字符串*) -- 原始 HTTP 路径组件，与 Web 服务器接收到的字节相同，没有修改。某些 Web 服务器实现可能无法提供此项。可选；如果缺失，则默认为 ``None``。

* ``query_string`` (*字节字符串*) -- ``?`` 后的 URL 部分。可选；如果缺失或为 ``None``，则默认为空字符串。

* ``root_path`` (*Unicode 字符串*) -- 此应用程序挂载到的根路径；与 WSGI 中的 ``SCRIPT_NAME`` 相同。可选；如果缺失，则默认为空字符串。

* ``headers`` (*Iterable[[字节字符串, 字节字符串]]*) -- 一个包含 ``[name, value]`` 两个元素可迭代对象的列表，其中 ``name`` 是标头名称，``value`` 是标头值。应该保留来自原始 HTTP 请求的顺序；重复项是可能的，并且必须在接收到的消息中保留。标头名称应该小写，但这不是必需的；服务器应该尽最大努力保留标头大小写。伪标头 (存在于 HTTP/2 和 HTTP/3 中) 必须删除；如果存在 ``:authority``，则其值必须使用 ``host`` 作为标头名称添加到可迭代对象的开头，或替换任何现有的 host 标头。

* ``client`` (*Iterable[Unicode 字符串, 整数]*) -- 一个包含 ``[host, port]`` 两个元素可迭代对象的列表，其中 ``host`` 是远程主机的 IPv4 或 IPv6 地址，``port`` 是远程端口。可选；如果缺失，则默认为 ``None``。

* ``server`` (*Iterable[Unicode 字符串, Optional[整数]]*) -- 一个包含 ``[host, port]`` 两个元素可迭代对象的列表，其中 ``host`` 是此服务器的监听地址，``port`` 是监听端口的整数，或 ``[path, None]``，其中 ``path`` 是 Unix 套接字的路径。可选；如果缺失，则默认为 ``None``。

* ``subprotocols`` (*Iterable[Unicode 字符串]*) -- 客户端通告的子协议。可选；如果缺失，则默认为空列表。

* ``state`` 可选(*dict[Unicode 字符串, Any]*) -- 传递到与该请求相对应的生命周期的命名空间的副本。（参见 :doc:`lifespan`)。可选；如果缺失，则表示服务器不支持此功能。


连接 - ``receive`` 事件
'''''''''''''''''''''''''''

当客户端最初打开连接并即将完成 WebSocket 握手时，发送到应用程序。

必须使用 *接受* 消息或 *关闭* 消息来回复此消息，套接字才会传递 ``websocket.receive`` 消息。协议服务器必须在 WebSocket 握手的过程中发送此消息，并且在收到回复之前不完成握手，如果连接被拒绝，则返回 HTTP 状态代码 ``403``。

键：

* ``type`` (*Unicode 字符串*) -- ``"websocket.connect"``。


接受 - ``send`` 事件
'''''''''''''''''''''''

当应用程序希望接受传入连接时，由应用程序发送。

* ``type`` (*Unicode 字符串*) -- ``"websocket.accept"``。

* ``subprotocol`` (*Unicode 字符串*) -- 服务器希望接受的子协议。可选；如果缺失，则默认为 ``None``。

* ``headers`` (*Iterable[[字节字符串, 字节字符串]]*) -- 一个包含 ``[name, value]`` 两个元素可迭代对象的列表，其中 ``name`` 是标头名称，``value`` 是标头值。顺序必须保留在 HTTP 响应中。标头名称必须小写。不得包含名为 ``sec-websocket-protocol`` 的标头；请改为使用 ``subprotocol`` 键。可选；如果缺失，则默认为空列表。* 在规范版本 2.1 中添加。* 伪标头 (存在于 HTTP/2 和 HTTP/3 中) 不得出现。


接收 - ``receive`` 事件
'''''''''''''''''''''''''''

当从客户端收到数据消息时，发送到应用程序。

键：

* ``type`` (*Unicode 字符串*) -- ``"websocket.receive"``。

* ``bytes`` (*字节字符串*) -- 消息内容，如果它是二进制模式，则为 ``None``。可选；如果缺失，则等效于 ``None``。

* ``text`` (*Unicode 字符串*) -- 消息内容，如果它是文本模式，则为 ``None``。可选；如果缺失，则等效于 ``None``。

``bytes`` 或 ``text`` 中只有一个必须为非 ``None``。但是，一个或两个键都可以存在。


发送 - ``send`` 事件
'''''''''''''''''''''

应用程序发送此事件以向客户端发送数据消息。

键：

* ``type`` (*Unicode 字符串*) -- ``"websocket.send"``。

* ``bytes`` (*字节字符串*) -- 二进制消息内容，或 ``None``。可选；如果缺失，则等效于 ``None``。

* ``text`` (*Unicode 字符串*) -- 文本消息内容，或 ``None``。可选；如果缺失，则等效于 ``None``。

``bytes`` 或 ``text`` 中只有一个必须为非 ``None``。但是，一个或两个键都可以存在。


.. _disconnect-receive-event-ws:

断开连接 - ``receive`` 事件
''''''''''''''''''''''''''''''

当客户端关闭连接、服务器关闭连接或套接字丢失时，无论是哪种原因导致与客户端的连接丢失，都发送到应用程序。

在你收到此事件后，你应该预计未来对 ``send()`` 的调用会引发异常，如上所述。但是，如果你的代码具有高度并发性，你可能会发现对 ``send()`` 的调用在收到此事件之前就稍微错误。

键：

* ``type`` (*Unicode 字符串*) -- ``"websocket.disconnect"``

* ``code`` (*整数*) -- WebSocket 关闭代码，符合 WebSocket 规范。如果在帧中没有从客户端收到代码，则服务器应该将其设置为 ``1005`` (WebSocket 规范中的默认值)。

* ``reason`` (*Unicode 字符串*) -- 断开连接的原因，可以是任何字符串。可选；如果缺失或为 ``None``，则默认为空字符串。


断开的客户端 - ``send`` 异常
''''''''''''''''''''''''''''''''''''''''

如果在已关闭的连接上调用 ``send()``，则服务器应该引发一个服务器特定的 ``IOError`` 子类。但这并非一定保证，尤其是在较旧的 ASGI 服务器实现中 (它是在规范版本 2.4 中引入的)。

应用程序可以捕获此异常，并在重新抛出或无异常返回之前执行清理工作。

服务器必须准备好捕获此异常（如果它们引发了此异常），并且不应该将其记录为其服务器日志中的错误。


关闭 - ``send`` 事件
''''''''''''''''''''''

应用程序发送此事件以指示服务器关闭连接。

如果在接受套接字之前发送此事件，则服务器必须使用 HTTP 403 错误代码 (禁止) 关闭连接，并且不完成 WebSocket 握手；这可能会在某些浏览器上显示为不同的 WebSocket 错误代码 (例如 1006，非正常关闭)。

如果在接受套接字之后发送此事件，则服务器必须使用消息中传递的关闭代码关闭套接字 (如果未指定，则使用 1000)。

* ``type`` (*Unicode 字符串*) -- ``"websocket.close"``。

* ``code`` (*整数*) -- WebSocket 关闭代码，符合 WebSocket 规范。可选；如果缺失，则默认为 ``1000``。

* ``reason`` (*Unicode 字符串*) -- 关闭的原因，可以是任何字符串。可选；如果缺失或为 ``None``，则默认为空字符串。


WSGI 兼容性
------------------

该规范中 HTTP 部分的设计目的之一是确保它与 WSGI 规范保持良好的一致性，以确保两种规范之间可以轻松适应，并能够将 WSGI 应用程序与 ASGI 服务器一起使用。

WSGI 应用程序是同步的，必须在线程池中运行才能被服务，但除此之外，它们的时间范围映射到 HTTP 连接范围的寿命。

WSGI 的 ``environ`` 变量中各种特殊键与 ``http`` 范围之间存在几乎直接的映射：

* ``REQUEST_METHOD`` 等同于 ``method``
* ``SCRIPT_NAME`` 等同于 ``root_path``
* 可以通过从 ``path`` 中删除 ``root_path`` 来获取 ``PATH_INFO``
* ``QUERY_STRING`` 等同于 ``query_string``
* 可以从 ``headers`` 中提取 ``CONTENT_TYPE``
* 可以从 ``headers`` 中提取 ``CONTENT_LENGTH``
* ``SERVER_NAME`` 和 ``SERVER_PORT`` 包含在 ``server`` 中
* ``REMOTE_HOST``/``REMOTE_ADDR`` 和 ``REMOTE_PORT`` 包含在 ``client`` 中
* ``SERVER_PROTOCOL`` 编码在 ``http_version`` 中
* ``wsgi.url_scheme`` 等同于 ``scheme``
* ``wsgi.input`` 是基于 ``http.request`` 消息的 ``StringIO``
* ``wsgi.errors`` 由包装器按需引导

``start_response`` 可调用对象与 ``http.response.start`` 类似地映射：

* ``status`` 参数变成 ``status``，并删除了原因短语。
* ``response_headers`` 映射到 ``headers``

从 WSGI 应用程序中产生内容等同于发送 ``http.response.body`` 消息。


WSGI 编码差异
-------------------------

WSGI 规范 (如 PEP 3333 中所定义) 规定，发送到服务器或从服务器发送的所有字符串都必须是 ``str`` 类型，但只能包含 ISO-8859-1 ("latin-1") 范围内的码位。这是因为它最初是为 Python 2 设计的，而 Python 2 具有不同的字符串类型。

ASGI HTTP 和 WebSocket 规范改为指定 ``scope`` 字典中的每个条目都是字节字符串或 Unicode 字符串。HTTP 是一种比较古老的协议，有时在指定编码方面存在缺陷，因此某些 Unicode 和字节的决策可能并不明显。

* ``path``: URL 可能同时包含百分号编码和 UTF-8 编码的部分。由于这些通常由底层服务器 (有时甚至代理) 进行解码，因此这是一个 Unicode 字符串，完全解码了 UTF-8 编码和百分号编码。

* ``headers``: 这些是来自客户端的 (或要由服务器发送的) 精确字节序列的字节字符串。虽然现代 HTTP 标准规定标头应该使用 ASCII，但旧的标准却没有规定，允许使用更广泛的字符。框架/应用程序应该根据需要解码标头。

* ``query_string``: 与 ``path`` 不同，它不受服务器干扰，因此以其原始百分号编码的字节字符串形式提供。

* ``root_path``: Unicode 字符串，与 ``path`` 匹配。


版本历史记录
---------------


* 2.0 (2017-11-28): 首个非通道层 ASGI 规范


版权
---------


本文档已归入公有领域。
